package {{main_package}}

import de.zalando.play.controllers.PlayBodyParsing
import org.scalacheck._
import org.scalacheck.Arbitrary._
import org.scalacheck.Prop._
import org.scalacheck.Test._
import org.specs2.mutable._
import play.api.test.Helpers._
import play.api.test._
import play.api.mvc.{QueryStringBindable, PathBindable}
import org.junit.runner.RunWith
import org.specs2.runner.JUnitRunner
import java.net.URLEncoder

import play.api.test.Helpers.{status => requestStatusCode_}

import Generators._

    @RunWith(classOf[JUnitRunner])
    class {{spec_name}} extends Specification {
        def toPath[T](value: T)(implicit binder: PathBindable[T]): String = binder.unbind("", value)
        def toQuery[T](key: String, value: T)(implicit binder: QueryStringBindable[T]): String = binder.unbind(key, value)
        def toHeader[T](value: T)(implicit binder: PathBindable[T]): String = binder.unbind("", value)

      def checkResult(props: Prop) =
        Test.check(Test.Parameters.default, props).status match {
          case Failed(_, labels) => failure(labels.mkString("\\n"))
          case Proved(_) | Exhausted | Passed => success
          case PropException(_, e, labels) =>
            val error = if (labels.isEmpty) e.getLocalizedMessage() else labels.mkString("\\n")
            failure(error)
        }

{{for test in tests}}

    "{{test.verb_name}} {{test.full_path}}" should {
        def testInvalidInput({{if test.multiple_parameters}}input: ({{for p in test.multiple_parameters}}{{p.type}}{{if p.isNotLast}}, {{/if}}{{/for}}){{/if}}{{for p in test.single_parameter}}{{p.name}}: {{p.type}}{{/for}}) = {

            {{if test.multiple_parameters}}
                val ({{for p in test.multiple_parameters}}{{p.name}}{{if p.isNotLast}}, {{/if}}{{/for}}) = input
            {{/if}}

            val url = {{test.full_url}}
            val headers = Seq({{for header in test.headers}}"{{header.name}}" -> toHeader({{header.name}}){{/for}})
            {{for b in test.body_param}}
                val parsed_{{b.body_parameter_name}} = PlayBodyParsing.jacksonMapper("{{b.expected_result_type}}").writeValueAsString({{b.body_parameter_name}})
            {{/for}}

            val path = route(FakeRequest({{test.verb_name}}, url).withHeaders(headers:_*){{for b in test.body_param}}.withBody(parsed_{{b.body_parameter_name}}){{/for}}).get
            val errors = new {{test.validation_name}}({{for p in test.multiple_parameters}}{{p.name}}{{if p.isNotLast}}, {{/if}}{{/for}}{{for p in test.single_parameter}}{{p.name}}{{/for}}).errors

            lazy val validations = errors flatMap { _.messages } map { m => contentAsString(path).contains(m) ?= true }

            ("given an URL: [" + url + "]" {{for b in test.body_param}}+ "and body [" + parsed_{{b.body_parameter_name}} + "]"{{/for}}) |: all(
                requestStatusCode_(path) ?= BAD_REQUEST ,
                contentType(path) ?= Some("{{test.expected_result_type}}"),
                errors.nonEmpty ?= true,
                all(validations:_*)
            )
        }
        def testValidInput({{if test.multiple_parameters}}input: ({{for p in test.multiple_parameters}}{{p.type}}{{if p.isNotLast}}, {{/if}}{{/for}}){{/if}}{{for p in test.single_parameter}}{{p.name}}: {{p.type}}{{/for}}) = {

            {{if test.multiple_parameters}}
                val ({{for p in test.multiple_parameters}}{{p.name}}{{if p.isNotLast}}, {{/if}}{{/for}}) = input
            {{/if}}

            {{for b in test.body_param}}
                val parsed_{{b.body_parameter_name}} = PlayBodyParsing.jacksonMapper("{{b.expected_result_type}}").writeValueAsString({{b.body_parameter_name}})
            {{/for}}

            val url = {{test.full_url}}
            val headers = Seq({{for header in test.headers}}"{{header.name}}" -> {{header.name}}{{/for}})
            val path = route(FakeRequest({{test.verb_name}}, url).withHeaders(headers:_*){{for b in test.body_param}}.withBody(parsed_{{b.body_parameter_name}}){{/for}}).get
            ("given an URL: [" + url + "]"{{for b in test.body_param}}+ " and body [" + parsed_{{b.body_parameter_name}} + "]"{{/for}}) |: (requestStatusCode_(path) ?= OK)
        }
        "discard invalid data" in new WithApplication {
            val genInputs = for {
                    {{for p in test.multiple_parameters}}
                        {{p.name}} <- {{p.generator}}
                    {{/for}}
                    {{for p in test.single_parameter}}{{p.name}} <- {{p.generator}}{{/for}}
                } yield{{if test.multiple_parameters}} ({{for p in test.multiple_parameters}}{{p.name}}{{if p.isNotLast}}, {{/if}}{{/for}}){{/if}}{{for p in test.single_parameter}} {{p.name}}{{/for}}
            val inputs = genInputs suchThat { {{if test.multiple_parameters}} case ({{for p in test.multiple_parameters}}{{p.name}}{{if p.isNotLast}}, {{/if}}{{/for}}){{/if}}{{for p in test.single_parameter}} {{p.name}}{{/for}} =>
                new {{test.validation_name}}({{for p in test.multiple_parameters}}{{p.name}}{{if p.isNotLast}}, {{/if}}{{/for}}{{for p in test.single_parameter}}{{p.name}}{{/for}}).errors.nonEmpty
            }
            val props = forAll(inputs) { i => testInvalidInput(i) }
            checkResult(props)
        }
        "do something with valid data" in new WithApplication {
            val genInputs = for {
                {{for p in test.multiple_parameters}}
                    {{p.name}} <- {{p.generator}}
                {{/for}}
                {{for p in test.single_parameter}}{{p.name}} <- {{p.generator}}{{/for}}
            } yield{{if test.multiple_parameters}} ({{for p in test.multiple_parameters}}{{p.name}}{{if p.isNotLast}}, {{/if}}{{/for}}){{/if}}{{for p in test.single_parameter}} {{p.name}}{{/for}}
            val inputs = genInputs suchThat { {{if test.multiple_parameters}} case ({{for p in test.multiple_parameters}}{{p.name}}{{if p.isNotLast}}, {{/if}}{{/for}}){{/if}}{{for p in test.single_parameter}} {{p.name}}{{/for}} =>
                new {{test.validation_name}}({{for p in test.multiple_parameters}}{{p.name}}{{if p.isNotLast}}, {{/if}}{{/for}}{{for p in test.single_parameter}}{{p.name}}{{/for}}).errors.isEmpty
            }
            val props = forAll(inputs) { i => testValidInput(i) }
            checkResult(props)
        }

    }
{{/for}}
}
