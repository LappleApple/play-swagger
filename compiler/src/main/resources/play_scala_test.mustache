package {{&main_package}}

import de.zalando.play.controllers.PlayBodyParsing
import org.scalacheck._
import org.scalacheck.Arbitrary._
import org.scalacheck.Prop._
import org.scalacheck.Test._
import org.specs2.mutable._
import play.api.test.Helpers._
import play.api.test._
import java.net.URLEncoder

{{#packages}}
{{#tests}}

    class {{&spec_name}} extends Specification {
      {{! TODO use specs2 scalacheck integration instead of doing this manually }}
      def checkResult(props: Prop) =
        Test.check(Test.Parameters.default, props).status match {
          case Failed(_, labels) => failure(labels.mkString("\\n"))
          case Proved(_) | Exhausted | Passed => success
          case PropException(_, _, labels) => failure(labels.mkString("\\n"))
        }

        "{{&verb_name}} {{&full_path}}" should {
            def testInvalidInput({{#parameters?}}input: ({{#parameters}}{{&type}}{{^last}}, {{/last}}{{/parameters}}){{/parameters?}}{{#single_parameter?}}{{&name}}: {{&type}}{{/single_parameter?}}) = {⮐
                {{#parameters?}}
                    val ({{#parameters}}{{&name}}{{^last}}, {{/last}}{{/parameters}}) = input
                {{/parameters?}}
                val url = {{&full_url}}

                {{#body?}}
                    val body = PlayBodyParsing.jacksonMapper("{{&expected_result_type}}").writeValueAsString({{&body_parameter_name}})
                {{/body?}}

                val path = route(FakeRequest({{verb_name}}, url){{#body?}}.withBody(body){{/body?}}).get
                val errors = new {{&validation_name}}({{#parameters?}}{{#parameters}}{{&name}}{{^last}}, {{/last}}{{/parameters}}{{/parameters?}}{{#single_parameter?}}{{&name}}{{/single_parameter?}}).errors⮐

                lazy val validations = errors map { m => contentAsString(path).contains(m) ?= true }

                ("given an URL: [" + url + "]" {{#body?}}+ "and body [" + body + "]"{{/body?}}) |: all(
                    status(path) ?= {{&expected_code}},
                    contentType(path) ?= Some("{{&expected_result_type}}"),
                    validations.nonEmpty ?= true,
                    all(validations:_*)
                )
            }
            def testValidInput({{#parameters?}}input: ({{#parameters}}{{&type}}{{^last}}, {{/last}}{{/parameters}}){{/parameters?}}{{#single_parameter?}}{{&name}}: {{&type}}{{/single_parameter?}}) = {⮐
                {{#parameters?}}
                    val ({{#parameters}}{{&name}}{{^last}}, {{/last}}{{/parameters}}) = input
                {{/parameters?}}
                {{#body?}}
                    val body = PlayBodyParsing.jacksonMapper("{{&expected_result_type}}").writeValueAsString({{&body_parameter_name}})
                {{/body?}}
                val url = {{&full_url}}
                val path = route(FakeRequest({{verb_name}}, url){{#body?}}.withBody(body){{/body?}}).get
                ("given an URL: [" + url + "]"{{#body?}}+ "and body [" + body + "]"{{/body?}}) |: (status(path) ?= OK)
            }
            "discard invalid data" in new WithApplication {
                val genInputs = for {
                        {{#parameters?}}{{#parameters}}
                            {{&name}} <- {{&generator}}
                        {{/parameters}}{{/parameters?}}
                        {{#single_parameter?}}{{&name}} <- {{&generator}}{{/single_parameter?}}⮐
                    } yield {{#parameters?}}({{#parameters}}{{&name}}{{^last}}, {{/last}}{{/parameters}}){{/parameters?}}{{#single_parameter?}}{{&name}}{{/single_parameter?}}⮐
                val inputs = genInputs suchThat { {{#parameters?}}case ({{#parameters}}{{&name}}{{^last}}, {{/last}}{{/parameters}}){{/parameters?}}{{#single_parameter?}}{{&name}}{{/single_parameter?}} =>
                    new {{&validation_name}}({{#parameters?}}{{#parameters}}{{&name}}{{^last}}, {{/last}}{{/parameters}}{{/parameters?}}{{#single_parameter?}}{{&name}}{{/single_parameter?}}).errors.nonEmpty
                }
                val props = forAll(inputs) { i => testInvalidInput(i) }
                checkResult(props)
            }
            "do something with valid data" in new WithApplication {
                val genInputs = for {
                    {{#parameters?}}{{#parameters}}
                        {{&name}} <- {{&generator}}
                    {{/parameters}}{{/parameters?}}
                    {{#single_parameter?}}{{&name}} <- {{&generator}}{{/single_parameter?}}⮐
                } yield {{#parameters?}}({{#parameters}}{{&name}}{{^last}}, {{/last}}{{/parameters}}){{/parameters?}}{{#single_parameter?}}{{&name}}{{/single_parameter?}}⮐
                val inputs = genInputs suchThat { {{#parameters?}}case ({{#parameters}}{{&name}}{{^last}}, {{/last}}{{/parameters}}){{/parameters?}}{{#single_parameter?}}{{&name}}{{/single_parameter?}} =>
                    new {{&validation_name}}({{#parameters?}}{{#parameters}}{{&name}}{{^last}}, {{/last}}{{/parameters}}{{/parameters?}}{{#single_parameter?}}{{&name}}{{/single_parameter?}}).errors.isEmpty
                }
                val props = forAll(inputs) { i => testValidInput(i) }
                checkResult(props)
            }

        }
    }
{{/tests}}
{{/packages}}