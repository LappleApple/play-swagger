package {{main_package}}

import play.api.mvc.{Action, Controller, Results}
import play.api.http._
import Results.Status
import de.zalando.play.controllers.{PlayBodyParsing, ParsingError, ResultWrapper}
import PlayBodyParsing._
import scala.util._
// import PickAvailableWriteable._ // if you want play to pick the first available writable
{{for import in imports}}
import {{import.name}}
{{/for}}
{{for import in binding_imports}}
import {{import.name}}
{{/for}}


{{for controller in controllers}}
trait {{controller.base}} extends Controller with PlayBodyParsing {{if controller.security_trait}} with {{controller.security_trait}} {{/if}}{
    {{for m in controller.methods}}
    sealed trait {{m.method}}Type[Result] extends ResultWrapper[Result]
    {{for result_type in m.result_types}}
    case class {{m.method}}{{result_type.code}}(result: {{result_type.type}})(implicit val writers: List[Writeable[{{result_type.type}}]]) extends {{m.method}}Type[{{result_type.type}}] { val statusCode = {{result_type.code}} }
    {{/for}}
    {{for mapping in m.error_mappings}}
    case class {{m.method}}{{mapping.exception_name}}(result: {{mapping.exception_name}}) extends {{m.method}}Type[{{mapping.exception_name}}] { val statusCode = {{mapping.exception_code}} }
    {{/for}}

    private type {{m.action_request_type}}       = ({{for v in m.validations}}{{for f in v.fields}}{{f.type_name}}{{if f.isNotLast}}, {{/if}}{{/for}}{{/for}}{{if m.has_no_validations}}Unit{{/if}})
    private type {{m.action_type}}[T]            = {{m.action_request_type}} => {{m.method}}Type[T]

    {{for body in m.body_param}}
        private def {{m.parser_name}}(acceptedTypes: Seq[String], maxLength: Int = parse.DefaultMaxTextLength) = {
            def bodyMimeType: Option[MediaType] => String = mediaType => {
                val requestType = mediaType.toSeq.map {
                    case m: MediaRange => m
                    case MediaType(a,b,c) => new MediaRange(a,b,c,None,Nil)
                }
                negotiateContent(requestType, acceptedTypes).orElse(acceptedTypes.headOption).getOrElse("application/json")
            }
            {{if m.needs_custom_readers}}
            {{else}}
            import de.zalando.play.controllers.WrappedBodyParsers
            {{/if}}
            val customParsers = WrappedBodyParsers.{{body.body_parser}}[{{body.parser_type}}]
            {{body.body_parser}}[{{body.parser_type}}](bodyMimeType, customParsers, "Invalid {{body.type_name}}", maxLength)
        }
    {{/for}}

    val {{m.action_constructor}}  = {{if m.needs_security}}{{if m.security_instance}}new {{/if}}{{m.secure_action}}{{for check in m.security_checks}}{{if check.params}}({{for param in check.params}}{{param.name}}{{if param.isNotLast}}, {{/if}}{{/for}}){{/if}}{{/for}}{{else}}Action{{/if}}
    def {{m.action}}[T] = (f: {{m.action_type}}[T]) =>{{if m.non_body_params}} ({{/if}}{{for p in m.non_body_params}}{{p.field_name}}: {{p.type_name}}{{if p.isNotLast}}, {{/if}}{{/for}}{{if m.non_body_params}}) =>{{/if}} {{m.action_constructor}}{{if m.body_param}}({{m.parser_name}}({{m.consumes}})){{/if}} { request =>
        val providedTypes = {{m.produces}}

        negotiateContent(request.acceptedTypes, providedTypes).map { {{m.response_mime_type_name}} =>

            {{for body in m.body_param}}
            val {{body.field_name}} = request.body
            {{/for}}
            {{for header in m.header_params}}
            val {{header.field_name}}: Either[String,{{header.type_name}}] =
                fromHeaders[{{header.type_name}}]("{{header.real_name}}", request.headers.toMap)
            {{/for}}
            {{if m.header_params}}
                ({{for header in m.header_params}}{{header.field_name}}{{if header.isNotLast}}, {{/if}}{{/for}}) match {
                    case ({{for header in m.header_params}}Right({{header.field_name}}){{if header.isNotLast}}, {{/if}}{{/for}}) =>
            {{/if}}

                val result ={{if m.has_no_validations}} {{m.process_valid_request}}(f)()({{m.response_mime_type_name}}){{/if}}
                    {{for v in m.validations}}
                        new {{v.validation_name}}({{for f in v.fields}}{{f.field_name}}{{if f.isNotLast}}, {{/if}}{{/for}}).errors match {
                            case e if e.isEmpty => {{m.process_valid_request}}(f)(({{for f in v.fields}}{{f.field_name}}{{if f.isNotLast}}, {{/if}}{{/for}}))({{m.response_mime_type_name}})
                            case l =>
                                implicit val marshaller: Writeable[Seq[ParsingError]] = parsingErrors2Writable({{m.response_mime_type_name}})
                                BadRequest(l)
                        }
                    {{/for}}
                result
            {{if m.header_params}}
                case ({{for h in m.header_params}}_{{if h.isNotLast}}, {{/if}}{{/for}}) =>
                    val problem: Seq[String] = Seq({{for h in m.header_params}}{{h.field_name}}{{if h.isNotLast}}, {{/if}}{{/for}}).filter{_.isLeft}.map(_.left.get)
                    val msg = problem.mkString("\n")
                    BadRequest(msg)
                }
            {{/if}}
        }.getOrElse(Status(415)("The server doesn't support any of the requested mime types"))
    }

    private def {{m.process_valid_request}}[T](f: {{m.action_type}}[T])(request: {{m.action_request_type}})(mimeType: String) = {
      f(request).toResult(mimeType).getOrElse {
        Results.NotAcceptable
      }
    }
    {{/for}}
    case object EmptyReturn extends ResultWrapper[Results.EmptyContent] {{for m in controller.methods}} {{if m.result_types}} {{else}} with {{m.method}}Type[Results.EmptyContent] {{/if}} {{/for}} { val statusCode = 204; val result = Results.EmptyContent(); val writers = List(new DefaultWriteables{}.writeableOf_EmptyContent); override def toResult(mimeType: String): Option[play.api.mvc.Result] = Some(Results.NoContent) }
    case object NotImplementedYet extends ResultWrapper[Results.EmptyContent] {{for m in controller.methods}} with {{m.method}}Type[Results.EmptyContent]{{/for}} { val statusCode = 501; val result = Results.EmptyContent(); val writers = List(new DefaultWriteables{}.writeableOf_EmptyContent); override def toResult(mimeType: String): Option[play.api.mvc.Result] = Some(Results.NotImplemented) }
}
{{/for}}