package {{main_package}}

import play.api.mvc.{Action, Controller, Results}
import play.api.http.Writeable
import Results.Status
import de.zalando.play.controllers.{PlayBodyParsing, ParsingError}
import PlayBodyParsing._
import scala.util._
{{for import in imports}}
import {{import.name}}
{{/for}}
{{for import in binding_imports}}
import {{import.name}}
{{/for}}


{{for controller in controllers}}

trait {{controller.base}} extends Controller with PlayBodyParsing {
    {{for m in controller.methods}}
    private type {{m.action_request_type}}       = ({{for v in m.validations}}{{for f in v.fields}}{{f.type_name}}{{if f.isNotLast}}, {{/if}}{{/for}}{{/for}}{{if m.has_no_validations}}Unit{{/if}})
    private type {{m.action_type}}              = {{m.action_request_type}} => Try[Any]

    private val {{m.error_to_status}}: PartialFunction[Throwable, Status] = {{if m.has_no_error_mappings}} PartialFunction.empty[Throwable, Status]{{/if}}
    {{if m.error_mappings}} { {{/if}}{{for mapping in m.error_mappings}}
        case _: {{mapping.exception_name}} => Status({{mapping.exception_code}})
    {{/for}}{{if m.error_mappings}} } {{/if}}

    {{for body in m.body_param}}
        private def {{m.parser_name}}(maxLength: Int = parse.DefaultMaxTextLength) = {{body.body_parser}}[{{body.parser_type}}]("{{m.request_mime_type_value}}", "Invalid {{body.type_name}}", maxLength)
    {{/for}}

    def {{m.action}} = (f: {{m.action_type}}) =>{{if m.non_body_params}} ({{/if}}{{for p in m.non_body_params}}{{p.field_name}}: {{p.type_name}}{{if p.isNotLast}}, {{/if}}{{/for}}{{if m.non_body_params}}) =>{{/if}} Action {{if m.body_param}}({{m.parser_name}}()){{/if}} { {{if m.request_needed}} request =>{{/if}}
        val {{m.response_mime_type_name}}    = "{{m.response_mime_type_value}}"

        val possibleWriters = Map{{if m.result_types}}(
            {{for result_type in m.result_types}}
                {{result_type.code}} -> anyToWritable[{{result_type.type}}]{{if result_type.isNotLast}}, {{/if}}
            {{/for}}
        ){{else}}.empty[Int,String => Writeable[Any]]{{/if}}{{if m.default_result_type}}.withDefaultValue(anyToWritable[{{m.default_result_type}}]){{/if}}
        {{for body in m.body_param}}
        val {{body.field_name}} = request.body
        {{/for}}
        {{for header in m.header_params}}
        val {{header.field_name}}_either =
            fromHeaders[{{header.type_name}}]("{{header.field_name}}", request.headers.toMap)
        {{/for}}
        {{if m.header_params}}
            ({{for header in m.header_params}}{{header.field_name}}_either{{if header.isNotLast}}, {{/if}}{{/for}}) match {
                case ({{for header in m.header_params}}Right({{header.field_name}}){{if header.isNotLast}}, {{/if}}{{/for}}) =>
        {{/if}}

            val result ={{if m.has_no_validations}} {{m.process_valid_request}}(f)(){{/if}}
                {{for v in m.validations}}
                    new {{v.validation_name}}({{for f in v.fields}}{{f.field_name}}{{if f.isNotLast}}, {{/if}}{{/for}}).errors match {
                        case e if e.isEmpty => {{m.process_valid_request}}(f)(({{for f in v.fields}}{{f.field_name}}{{if f.isNotLast}}, {{/if}}{{/for}}), possibleWriters, {{m.response_mime_type_name}})
                        case l =>
                            implicit val marshaller: Writeable[Seq[ParsingError]] = parsingErrors2Writable({{m.response_mime_type_name}})
                            BadRequest(l)
                    }
                {{/for}}
            result
        {{if m.header_params}}
            case ({{for h in m.header_params}}_{{if h.isNotLast}}, {{/if}}{{/for}}) =>
                val msg = Seq({{for h in m.header_params}}{{h.field_name}}_either{{if h.isNotLast}}, {{/if}}{{/for}}).filter{_.isLeft}.map(_.left.get).mkString("\n")
                BadRequest(msg)
            }
        {{/if}}

    }

    private def {{m.process_valid_request}}[T <: Any](f: {{m.action_type}})(request: {{m.action_request_type}}, writers: Map[Int, String => Writeable[T]], mimeType: String) = {
        val callerResult = f(request)
        val status = callerResult match {
            case Failure(error) => ({{m.error_to_status}} orElse defaultErrorMapping)(error)
            case Success((code: Int, result: T @ unchecked)) =>
                writers.get(code).map { writer =>
                    implicit val {{m.writable_json}} = writer(mimeType)
                    Status(code)(result)
                }.getOrElse {
                    implicit val errorWriter = anyToWritable[IllegalStateException](mimeType)
                    Status(500)(new IllegalStateException(s"Response code was not defined in specification: $code"))
                }
        }
        status
    }
    {{/for}}
}
{{/for}}